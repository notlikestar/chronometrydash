<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Geometry Dash Mini â€“ Perfect Spacing</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    background: #000;
    touch-action: none;
  }
  canvas { background:#000; display:block; }
</style>
</head>
<body>

<canvas id="game"></canvas>

<div id="scoreDisplay" style="
  position:absolute;top:20px;left:20px;
  color:#0ff;font:32px monospace;">
  Score: 0
</div>

<script>
// ------------------------------------------------------------
// CANVAS
// ------------------------------------------------------------
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
let W = innerWidth, H = innerHeight;
canvas.width = W; canvas.height = H;

let ground = H - 120;

// ------------------------------------------------------------
// BACKGROUND STARFIELD
// ------------------------------------------------------------
const starLayers = [
  { speed: 0.3, count: 60, stars: [] },
  { speed: 0.6, count: 40, stars: [] },
  { speed: 1.0, count: 20, stars: [] }
];

function initStars(){
  starLayers.forEach(l=>{
    l.stars = Array.from({length:l.count}, ()=>({
      x: Math.random()*W,
      y: Math.random()*H,
      size: Math.random()*2+1
    }));
  });
}
function drawStars(){
  ctx.fillStyle="#fff";
  starLayers.forEach(l=>{
    l.stars.forEach(s=>{
      s.x -= l.speed;
      if(s.x < 0) s.x = W;
      ctx.fillRect(s.x,s.y,s.size,s.size);
    });
  });
}
initStars();

// ------------------------------------------------------------
// CUBE TEXTURE
// ------------------------------------------------------------
let cubeImg = new Image();
let cubeImgLoaded = false;
cubeImg.onload = ()=> cubeImgLoaded = true;
cubeImg.onerror = ()=> cubeImgLoaded = false;

cubeImg.src = "chronometry dash/assets/crate.png";

// ------------------------------------------------------------
// PLAYER
// ------------------------------------------------------------
let cube = {
  x:120,
  y:ground-60,
  size:60,
  dy:0,
  gravity:1.1,
  jumpForce:-19,
  jumping:false,
  rotation:0,
  rotationSpeed:0,
  targetRotation:0,
  airFrames:0
};

function calcAirFrames(){
  let vel = cube.jumpForce;
  let frames = 0;
  while(true){
    vel += cube.gravity;
    frames++;
    if(vel > 0 && frames > 3 && vel*frames > 65) break;
  }
  return frames;
}

function jump(){
  if(!cube.jumping){
    cube.dy = cube.jumpForce;
    cube.jumping = true;
    cube.airFrames = calcAirFrames();
    cube.rotationSpeed = 90 / cube.airFrames;
    cube.targetRotation = cube.rotation + 90;
  }
}

// ------------------------------------------------------------
// OBSTACLES
// ------------------------------------------------------------
let obstacles = [];

// Perfect spacing based on your physics
const GAP_SINGLE = 260;
const GAP_DOUBLE = 330;
const GAP_AFTER_PATTERN = 260;

function ensureGap(x){
  if(obstacles.length === 0) return x;

  let last = obstacles[obstacles.length-1];
  let lastRight = last.x + last.w;

  if(x - lastRight < GAP_SINGLE){
    return lastRight + GAP_SINGLE;
  }
  return x;
}

function pushSingleSpike(x){
  obstacles.push({
    type:"single",
    x:x,
    y:ground,
    w:60,
    h:60,
    passed:false
  });
}

function pushDoubleSpike(x){
  obstacles.push({
    type:"single",
    x:x,
    y:ground,
    w:60,
    h:60,
    passed:false
  });

  obstacles.push({
    type:"single",
    x:x + GAP_DOUBLE,
    y:ground,
    w:60,
    h:60,
    passed:false
  });
}

function pushTriplePack(x){
  pushSingleSpike(x);
  pushSingleSpike(x + GAP_DOUBLE);
  pushSingleSpike(x + GAP_DOUBLE * 2);
}

// ------------------------------------------------------------
// PATTERN GENERATOR
// ------------------------------------------------------------
function spawnPattern(){
  let r = Math.random();

  // Single spike
  if(r < 0.45){
    let px = ensureGap(W + 60);
    pushSingleSpike(px);
    return;
  }

  // Clean double
  if(r < 0.75){
    let px = ensureGap(W + 60);
    pushDoubleSpike(px);
    return;
  }

  // Triple pack
  if(r < 0.95){
    let px = ensureGap(W + 60);
    pushTriplePack(px);
    return;
  }

  // Combo pattern: single -> double
  let px = ensureGap(W + 60);
  pushSingleSpike(px);
  pushDoubleSpike(px + GAP_DOUBLE + GAP_SINGLE);
}

// ------------------------------------------------------------
// DRAW SPIKES
// ------------------------------------------------------------
function drawSpike(o){
  ctx.fillStyle = "#f00";
  ctx.beginPath();
  ctx.moveTo(o.x, o.y);
  ctx.lineTo(o.x + o.w/2, o.y - o.h);
  ctx.lineTo(o.x + o.w, o.y);
  ctx.closePath();
  ctx.fill();
}

// ------------------------------------------------------------
// HITBOX
// ------------------------------------------------------------
function pointInTri(px,py,ax,ay,bx,by,cx,cy){
  const area = Math.abs((bx-ax)*(cy-ay)-(cx-ax)*(by-ay));
  const a1 = Math.abs((ax-px)*(by-py)-(bx-px)*(ay-py));
  const a2 = Math.abs((bx-px)*(cy-py)-(cx-px)*(by-py));
  const a3 = Math.abs((cx-px)*(ay-py)-(ax-px)*(cy-py));
  return Math.abs(area-(a1+a2+a3))<0.2;
}

function cubeHitsSpike(c,o){
  let ax=o.x, ay=o.y;
  let bx=o.x+o.w/2, by=o.y-o.h;
  let cx=o.x+o.w, cy=o.y;

  let corners = [
    [c.x,c.y],
    [c.x+c.size,c.y],
    [c.x,c.y+c.size],
    [c.x+c.size,c.y+c.size]
  ];
  for(let k of corners)
    if(pointInTri(k[0],k[1],ax,ay,bx,by,cx,cy))
      return true;
  return false;
}

// ------------------------------------------------------------
// EXPLOSION
// ------------------------------------------------------------
let particles=[];
function explode(x,y){
  for(let i=0;i<20;i++){
    particles.push({
      x,y,
      dx:(Math.random()-0.5)*14,
      dy:(Math.random()-1.2)*14,
      size:Math.random()*6+3,
      a:1
    });
  }
}

function drawParticles(){
  particles.forEach(p=>{
    ctx.fillStyle=`rgba(255,0,0,${p.a})`;
    ctx.fillRect(p.x,p.y,p.size,p.size);
    p.x+=p.dx;
    p.y+=p.dy;
    p.dy+=0.4;
    p.a-=0.03;
  });
  particles = particles.filter(p=>p.a>0);
}

// ------------------------------------------------------------
// DRAW CUBE
// ------------------------------------------------------------
function drawCube(){
  ctx.save();
  ctx.translate(cube.x+cube.size/2, cube.y+cube.size/2);
  ctx.rotate(cube.rotation*Math.PI/180);
  ctx.shadowBlur=25;
  ctx.shadowColor="#0ff";

  if(cubeImgLoaded)
    ctx.drawImage(cubeImg,-cube.size/2,-cube.size/2,cube.size,cube.size);
  else {
    ctx.fillStyle="#0ff";
    ctx.fillRect(-cube.size/2,-cube.size/2,cube.size,cube.size);
  }
  ctx.restore();
}

// ------------------------------------------------------------
// GAME STATE
// ------------------------------------------------------------
let gameOver=false;
let gameSpeed=10;
let score=0;
let frame=0;

// ------------------------------------------------------------
// UPDATE + LOOP
// ------------------------------------------------------------
function updateCube(){
  cube.dy += cube.gravity;
  cube.y += cube.dy;

  if(cube.jumping){
    cube.rotation += cube.rotationSpeed;
    if(cube.rotation > cube.targetRotation)
      cube.rotation = cube.targetRotation;
  }

  if(cube.y + cube.size >= ground){
    cube.y = ground - cube.size;
    cube.dy = 0;
    cube.jumping = false;
    cube.rotation = Math.round(cube.rotation/90)*90;
  }
}

function updateObstacles(){
  obstacles.forEach(o=>{
    o.x -= gameSpeed;

    if(!o.passed && o.x+o.w < cube.x){
      score++;
      document.getElementById("scoreDisplay").innerText="Score: "+score;
      o.passed = true;
    }
  });

  obstacles = obstacles.filter(o=>o.x+o.w > 0);
}

function checkCollision(){
  for(let o of obstacles){
    if(cubeHitsSpike(cube,o)){
      explode(cube.x+cube.size/2, cube.y+cube.size/2);
      gameOver=true;
      setTimeout(reset,1500);
      return;
    }
  }
}

function reset(){
  cube.x=120;
  cube.y=ground-60;
  cube.dy=0;
  cube.rotation=0;
  cube.jumping=false;

  obstacles=[];
  particles=[];
  score=0;
  document.getElementById("scoreDisplay").innerText="Score: 0";
  gameOver=false;
  frame=0;
}

function loop(){
  ctx.clearRect(0,0,W,H);
  drawStars();

  ctx.fillStyle="#111";
  ctx.fillRect(0,ground,W,300);

  obstacles.forEach(drawSpike);
  drawParticles();
  if(!gameOver) drawCube();

  if(!gameOver){
    frame++;
    if(frame % 110 === 0) spawnPattern();

    updateCube();
    updateObstacles();
    checkCollision();
  }

  requestAnimationFrame(loop);
}
loop();

// ------------------------------------------------------------
// INPUT
// ------------------------------------------------------------
addEventListener("keydown",e=>{ if(e.code==="Space") jump(); });
addEventListener("touchstart", jump);

// ------------------------------------------------------------
// RESIZE
// ------------------------------------------------------------
addEventListener("resize",()=>{
  W=innerWidth; H=innerHeight;
  canvas.width=W; canvas.height=H;
  ground=H-120;
  initStars();
});
</script>
</body>
</html>
