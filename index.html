<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>Geometry Dash Mini â€“ Offscreen Spawn Fix</title>
<style>
  html,body{margin:0;padding:0;background:#000;overflow:hidden;touch-action:none}
  canvas{display:block;background:#000}
  #score{position:absolute;top:20px;left:20px;color:#0ff;font:32px monospace}
</style>
</head>
<body>

<canvas id="game"></canvas>
<div id="score">Score: 0</div>

<script>
// ============================================================
// CANVAS
// ============================================================
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
let W = innerWidth, H = innerHeight;
canvas.width = W; canvas.height = H;

let ground = H - 120;

// ============================================================
// STARFIELD
// ============================================================
const starLayers = [
  {speed:0.3, count:60, stars:[]},
  {speed:0.6, count:40, stars:[]},
  {speed:1.0, count:20, stars:[]}
];

function initStars(){
  starLayers.forEach(l=>{
    l.stars = Array.from({length:l.count}, ()=>({
      x:Math.random()*W,
      y:Math.random()*H,
      s:Math.random()*2+1
    }));
  });
}
function drawStars(){
  ctx.fillStyle="#fff";
  starLayers.forEach(l=>{
    l.stars.forEach(s=>{
      s.x -= l.speed;
      if(s.x < 0) s.x = W;
      ctx.fillRect(s.x, s.y, s.s, s.s);
    });
  });
}
initStars();

// ============================================================
// PLAYER
// ============================================================
const cube = {
  x:120,
  targetX:120,
  y:ground-60,
  size:60,
  dy:0,
  gravity:1.1,
  jumpForce:-19,
  jumping:false,
  rotation:0,
  rotationSpeed:0,
  targetRotation:0
};

function calcAirFrames(){
  let v=cube.jumpForce, f=0;
  while(true){
    v+=cube.gravity; f++;
    if(v>0 && f>3 && v*f>65) break;
  }
  return f;
}

function jump(){
  if(cube.jumping) return;
  cube.dy = cube.jumpForce;
  cube.jumping=true;
  let f=calcAirFrames();
  cube.rotationSpeed=90/f;
  cube.targetRotation = cube.rotation + 90;
}

function drawCube(){
  ctx.save();
  ctx.translate(cube.x+cube.size/2, cube.y+cube.size/2);
  ctx.rotate(cube.rotation*Math.PI/180);
  ctx.shadowBlur=25;
  ctx.shadowColor="#0ff";
  ctx.fillStyle="#0ff";
  ctx.fillRect(-cube.size/2, -cube.size/2, cube.size, cube.size);
  ctx.restore();
}

// ============================================================
// INPUT
// ============================================================
addEventListener("keydown", e=>{
  if(e.code==="Space") jump();
});
let tX=0,tY=0,moved=false;
addEventListener("touchstart", e=>{
  let t=e.touches[0];
  tX=t.clientX; tY=t.clientY;
  moved=false;
});
addEventListener("touchmove", e=>{
  let t=e.touches[0];
  if(Math.abs(t.clientX-tX)>10 || Math.abs(t.clientY-tY)>10)
    moved=true;
});
addEventListener("touchend", ()=>{
  if(!moved) jump();
});

// ============================================================
// OBSTACLES
// ============================================================
let obstacles=[];

// FINAL SPACING RULES
const GAP_SPIKE = 520;    
const GAP_SPECIAL = 420;  
const GAP_BACK = 260;     

const GAP_DOUBLE = 330;
const PIT_MIN = 180, PIT_MAX = 230;

const WALL_W = 20;
const WALL_H = 120;

// how far off-screen obstacles spawn
const SPAWN_MARGIN = 200;

// ============================================================
// GROUP HELPERS
// ============================================================
function groupWidth(o){
  if(o.type==="spike") return 60;
  if(o.type==="double") return 60 + GAP_DOUBLE;
  if(o.type==="triple") return 60 + GAP_DOUBLE*2;
  if(o.type==="pit") return o.w;
  if(o.type==="wall") return WALL_W;
  return 60;
}

function groupEnd(o){ return o.x + groupWidth(o); }

function baseGap(type){
  if(type==="pit" || type==="wall") return GAP_SPECIAL;
  return GAP_SPIKE;
}

// NEW: always start from OFF-SCREEN X
function nextX(type){
  if(obstacles.length === 0) return W + SPAWN_MARGIN;

  let last = obstacles[obstacles.length - 1];
  let end = groupEnd(last);

  let desired = Math.max(end + baseGap(type), W + SPAWN_MARGIN);

  // back-to-back compression
  if(desired - end < 300){
    desired = end + GAP_BACK;
  }

  return desired;
}

// ============================================================
// SPAWN
// ============================================================
function pushSpike(x){ obstacles.push({type:"spike",x,y:ground,passed:false}); }
function pushDouble(x){ obstacles.push({type:"double",x,y:ground,passed:false}); }
function pushTriple(x){ obstacles.push({type:"triple",x,y:ground,passed:false}); }
function pushPit(x){
  let w=PIT_MIN + Math.random()*(PIT_MAX-PIT_MIN);
  obstacles.push({type:"pit",x,y:ground,w,passed:false});
}
function pushWall(x){
  obstacles.push({
    type:"wall",
    x, y:ground-WALL_H,
    w:WALL_W,h:WALL_H,
    shattered:false,
    passed:false
  });
}

// ============================================================
// PATTERN GENERATION
// ============================================================
function spawnPattern(){
  let r = Math.random();

  if(r<0.15){ pushWall(nextX("wall")); return; }
  if(r<0.25){ pushPit(nextX("pit")); return; }
  if(r<0.55){ pushSpike(nextX("spike")); return; }
  if(r<0.80){ pushDouble(nextX("double")); return; }
  if(r<0.95){ pushTriple(nextX("triple")); return; }

  pushSpike(nextX("spike"));
  pushDouble(nextX("double"));
}

// ============================================================
// DRAW
// ============================================================
function drawSpike(o){
  ctx.fillStyle="#f00";
  ctx.beginPath();
  ctx.moveTo(o.x,o.y);
  ctx.lineTo(o.x+30,o.y-60);
  ctx.lineTo(o.x+60,o.y);
  ctx.closePath(); ctx.fill();
}
function drawDouble(o){
  drawSpike({x:o.x,y:ground});
  drawSpike({x:o.x+GAP_DOUBLE,y:ground});
}
function drawTriple(o){
  drawSpike({x:o.x,y:ground});
  drawSpike({x:o.x+GAP_DOUBLE,y:ground});
  drawSpike({x:o.x+GAP_DOUBLE*2,y:ground});
}
function drawPit(o){
  ctx.fillStyle="#000";
  ctx.fillRect(o.x,ground,o.w,300);
}
function drawWall(o){
  ctx.fillStyle="#bbb";
  ctx.fillRect(o.x,o.y,o.w,o.h);
}

// ============================================================
// SHATTER
// ============================================================
let shards=[];
function shatter(x,y){
  for(let i=0;i<30;i++){
    shards.push({
      x,y,
      dx:Math.random()*6-3,
      dy:Math.random()*-6,
      s:Math.random()*5+2,
      a:1
    });
  }
}
function drawShards(){
  shards.forEach(s=>{
    ctx.fillStyle=`rgba(200,220,255,${s.a})`;
    ctx.fillRect(s.x,s.y,s.s,s.s);
    s.x+=s.dx;
    s.y+=s.dy;
    s.dy+=0.25;
    s.a-=0.035;
  });
  shards = shards.filter(s=>s.a>0);
}

// ============================================================
// COLLISION
// ============================================================
function cubeHitsSpike(c,o){
  let ax=o.x, ay=o.y;
  let bx=o.x+30, by=o.y-60;
  let cx=o.x+60, cy=o.y;

  let pts=[
    [c.x,c.y],[c.x+c.size,c.y],
    [c.x,c.y+c.size],[c.x+c.size,c.y+c.size]
  ];

  const A=Math.abs((bx-ax)*(cy-ay)-(cx-ax)*(by-ay));

  for(let p of pts){
    let px=p[0], py=p[1];
    let A1=Math.abs((ax-px)*(by-py)-(bx-px)*(ay-py));
    let A2=Math.abs((bx-px)*(cy-py)-(cx-px)*(by-py));
    let A3=Math.abs((cx-px)*(ay-py)-(ax-px)*(cy-py));
    if(Math.abs(A-(A1+A2+A3))<0.3) return true;
  }
  return false;
}

function cubeFallsInPit(c,o){
  return(c.x+c.size>o.x && c.x<o.x+o.w && c.y+c.size>=ground);
}

function cubeHitsWall(c,o){
  return(
    c.x+c.size>o.x &&
    c.x<o.x+o.w &&
    c.y+c.size>o.y &&
    c.y<o.y+o.h
  );
}

// ============================================================
// GAME LOOP
// ============================================================
let gameSpeed=10;
let score=0;
let frame=0;
let gameOver=false;

function updateCube(){
  cube.dy+=cube.gravity;
  cube.y+=cube.dy;

  if(cube.jumping){
    cube.rotation+=cube.rotationSpeed;
    if(cube.rotation>cube.targetRotation)
      cube.rotation=cube.targetRotation;
  }

  if(cube.y+cube.size>=ground){
    cube.y=ground-cube.size;
    cube.dy=0;
    cube.jumping=false;
    cube.rotation=Math.round(cube.rotation/90)*90;
  }

  cube.x += (cube.targetX - cube.x)*0.25;
}

function updateObstacles(){
  obstacles.forEach(o=>{
    o.x -= gameSpeed;

    if(o.type==="wall" && !o.shattered && cubeHitsWall(cube,o)){
      o.shattered=true;
      shatter(o.x+o.w/2,o.y+o.h/2);
      cube.targetX=160;
      setTimeout(()=>cube.targetX=120,120);
    }

    if(!o.passed && groupEnd(o) < cube.x){
      o.passed=true;
      score++;
      document.getElementById("score").innerText="Score: "+score;
    }
  });

  obstacles = obstacles.filter(o => o.x + groupWidth(o) > 0);
}

function die(){
  shatter(cube.x+cube.size/2,cube.y+cube.size/2);
  gameOver=true;
  setTimeout(reset,1500);
}

function checkCollision(){
  for(let o of obstacles){
    if(o.type==="spike" && cubeHitsSpike(cube,o)) return die();
    if(o.type==="double"){
      if(
        cubeHitsSpike(cube,{x:o.x,y:ground}) ||
        cubeHitsSpike(cube,{x:o.x+GAP_DOUBLE,y:ground})
      ) return die();
    }
    if(o.type==="triple"){
      if(
        cubeHitsSpike(cube,{x:o.x,y:ground}) ||
        cubeHitsSpike(cube,{x:o.x+GAP_DOUBLE,y:ground}) ||
        cubeHitsSpike(cube,{x:o.x+GAP_DOUBLE*2,y:ground})
      ) return die();
    }
    if(o.type==="pit" && cubeFallsInPit(cube,o)) return die();
  }
}

function reset(){
  cube.x=120;
  cube.targetX=120;
  cube.y=ground-60;
  cube.dy=0;
  cube.jumping=false;
  cube.rotation=0;

  obstacles=[];
  shards=[];
  score=0;
  document.getElementById("score").innerText="Score: 0";

  gameOver=false;
  frame=0;
}

// ============================================================
// MAIN LOOP
// ============================================================
function loop(){
  ctx.clearRect(0,0,W,H);

  drawStars();

  ctx.fillStyle="#111";
  ctx.fillRect(0,ground,W,300);

  obstacles.forEach(o=>{
    if(o.type==="spike") drawSpike(o);
    else if(o.type==="double") drawDouble(o);
    else if(o.type==="triple") drawTriple(o);
    else if(o.type==="pit") drawPit(o);
    else if(o.type==="wall") drawWall(o);
  });

  drawShards();

  if(!gameOver) drawCube();

  if(!gameOver){
    frame++;
    if(frame % 75 === 0) spawnPattern();
    updateCube();
    updateObstacles();
    checkCollision();
  }

  requestAnimationFrame(loop);
}
loop();

// ============================================================
// RESIZE
// ============================================================
addEventListener("resize", ()=>{
  W=innerWidth; H=innerHeight;
  canvas.width=W; canvas.height=H;
  ground=H-120;
  initStars();
});
</script>
</body>
</html>
